package scorex.block

import io.circe.Json
import scorex.consensus.ConsensusModule
import scorex.serialization.{BytesSerializable, JsonSerializable}
import scorex.transaction.box.Proposition
import scorex.transaction.{Transaction, TransactionModule}
import scorex.utils.ScorexLogging
import shapeless._

import scala.util.Try

/**
  * A block is an atomic piece of data network participates are agreed on.
  *
  * A block has:
  * - transactions data: a sequence of transactions, where a transaction is an atomic state update.
  * Some metadata is possible as well(transactions Merkle tree root, state Merkle tree root etc).
  *
  * - consensus data to check whether block was generated by a right party in a right way. E.g.
  * "baseTarget" & "generatorSignature" fields in the Nxt block structure, nonce & difficulty in the
  * Bitcoin block structure.
  *
  * - a signature(s) of a block generator(s)
  *
  * - additional data: block structure version no, timestamp etc
  */

class Block[P <: Proposition, CData <: ConsensusData, TData <: TransactionalData[_]](
                                                                             val version: Byte,
                                                                             val timestamp: Long,
                                                                             val consensusData: CData,
                                                                             val transactionalData: TData)
  extends BytesSerializable with JsonSerializable {

  type TDataExposed = TData
  type BlockId = ConsensusData.BlockId

  val blockFields = version :: timestamp :: consensusData.consensusFields :: transactionalData.transactionalFields :: HNil

  lazy val bytes: Array[Byte] = ???

  lazy val json: Json = ???

  /*lazy val json =
    versionField.json ++
      timestampField.json ++
      consensusDataField.json ++
      transactionDataField.json ++
      Json.obj(
        "fee" -> consensusModule.totalFee(this),
        "blocksize" -> bytes.length
      )*/

  /*
  override def equals(obj: Any): Boolean = obj match {
    case b: Block => consensusModule.id(b).unsized sameElements consensusModule.id(this).unsized
    case _ => false
  } */
}

object SerializeToBytes extends Poly1 {
  implicit def caseByte = at[Byte](b => Array(b))

  implicit def caseBytesSerializable[B <: BytesSerializable] = at[B](_.bytes)

  implicit def default[A] = at[A](a => a)
}


trait ConsensusData {
  import ConsensusData.BlockId

  val BlockIdLength: Int

  type ConsensusFields <: HList

  val consensusFields: ConsensusFields

  val parentId: BlockId
}

object ConsensusData {
  type BlockId = Array[Byte]
}

trait TransactionalData[TX <: Transaction[_, TX]] {
  type TransactionalHeaderFields <: HList

  val mbTransactions: Option[Traversable[TX]]

  val transactionalHeaderFields: TransactionalHeaderFields

  val headerOnly = mbTransactions.isDefined

  val transactionalFields = mbTransactions match {
    case Some(txs) => transactionalHeaderFields :: txs :: HNil
    case None => transactionalHeaderFields
  }
}

object Block extends ScorexLogging {
  val Version = 1: Byte


  def parse[P <: Proposition, CData <: ConsensusData, TData <: TransactionalData[_], B <: Block[P, CData, TData]](bytes: Array[Byte])
                                                                  (implicit consensusModule: ConsensusModule[P, CData, B],
                                                                   transactionalModule: TransactionModule[P, _, TData]): Try[B] = {
    ???
  }

  def build[P <: Proposition, TX <: Transaction[P, TX], CData <: ConsensusData, TData <: TransactionalData[TX]](consensusData: CData)
                                                                                             (implicit transactionalModule: TransactionModule[P, TX, TData]): Block[P, CData, TData] = {
    val timestamp = System.currentTimeMillis()
    new Block(Version, timestamp, consensusData, transactionalModule.packUnconfirmed())
  }

  def genesis[P <: Proposition, CData <: ConsensusData, TData <: TransactionalData[_]](genesisTimestamp: Long)
                                                                    (implicit consensusModule: ConsensusModule[P, CData, _ <: Block[P, CData, TData]],
                                                                     transactionalModule: TransactionModule[P, _, TData]): Block[P, CData, TData] = {
    new Block(Version, genesisTimestamp, consensusModule.genesisData, transactionalModule.genesisData)
  }

  def isValid[P <: Proposition, CData <: ConsensusData, TData <: TransactionalData[_], B <: Block[P, CData, TData]](block: B)(implicit consensusModule: ConsensusModule[P, CData, B],
                                                                                                 transactionalModule: TransactionModule[P, _, TData]): Boolean = {
    if (consensusModule.contains(block)) true //applied blocks are valid
    else {
      lazy val consensus = consensusModule.isValid(block)
      lazy val transaction = transactionalModule.isValid(block)

      if (!consensus) log.debug(s"Invalid block ${consensusModule.encodedId(block)}: consensus data is not valid")
      else if (!transaction) log.debug(s"Invalid block ${consensusModule.encodedId(block)}: transaction data is not valid")

      consensus && transaction
    }
  }
}