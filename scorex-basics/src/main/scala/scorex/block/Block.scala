package scorex.block

import com.google.common.primitives.{Ints, Longs}
import play.api.libs.json.Json
import scorex.consensus.ConsensusModule
import scorex.crypto.encode.Base58
import scorex.serialization.BytesSerializable
import scorex.transaction.TransactionModule
import scorex.utils.ScorexLogging

import scala.util.{Failure, Try}

/**
  * A block is an atomic piece of data network participates are agreed on.
  *
  * A block has:
  * - transactions data: a sequence of transactions, where a transaction is an atomic state update.
  * Some metadata is possible as well(transactions Merkle tree root, state Merkle tree root etc).
  *
  * - consensus data to check whether block was generated by a right party in a right way. E.g.
  * "baseTarget" & "generatorSignature" fields in the Nxt block structure, nonce & difficulty in the
  * Bitcoin block structure.
  *
  * - a signature(s) of a block generator(s)
  *
  * - additional data: block structure version no, timestamp etc
  */

trait Block extends BytesSerializable with ScorexLogging {

  type TM <: TransactionModule
  type CM <: ConsensusModule[TM]

  implicit val transactionModule: TM
  implicit val consensusModule: CM

  type ConsensusDataType = consensusModule.ConsensusBlockData
  type TransactionDataType = transactionModule.TBD

  val consensusDataField: BlockField[ConsensusDataType]
  val transactionDataField: BlockField[TransactionDataType]

  val versionField: ByteBlockField
  val timestampField: LongBlockField

  lazy val id = consensusModule.id(this)

  lazy val parentId = consensusModule.parentId(this)

  lazy val encodedId: String = Base58.encode(consensusModule.id(this))

  lazy val transactions = transactionModule.transactions(this)

  lazy val totalFee = consensusModule.feesDistribution(this).values.sum

  lazy val json =
    versionField.json ++
      timestampField.json ++
      consensusDataField.json ++
      transactionDataField.json ++
      Json.obj(
        "fee" -> totalFee,
        "blocksize" -> bytes.length
      )

  lazy val bytes = {
    val txBytesSize = transactionDataField.bytes.length
    val txBytes = Ints.toByteArray(txBytesSize) ++ transactionDataField.bytes

    val cBytesSize = consensusDataField.bytes.length
    val cBytes = Ints.toByteArray(cBytesSize) ++ consensusDataField.bytes

    versionField.bytes ++
      timestampField.bytes ++
      cBytes ++
      txBytes
  }

  lazy val producers = consensusModule.producers(this)

  def isValid: Boolean = {
    if (consensusModule.history.contains(this)) true //applied blocks are valid
    else {
      lazy val consensus = consensusModule.isValid(this)
      lazy val transaction = transactionModule.isValid(this)

      if (!consensus) log.debug(s"Invalid block $encodedId: consensus data is not valid")
      else if (!transaction) log.debug(s"Invalid block $encodedId: transaction data is not valid")

      consensus && transaction
    }
  }

  override def equals(obj: Any): Boolean = obj match {
    case b: Block => consensusModule.id(b) sameElements consensusModule.id(this)
    case _ => false
  }
}


object Block extends ScorexLogging {
  type BlockId = Array[Byte]

  //TODO BytesParseable[Block] ??
  def parseBytes[TMOD <: TransactionModule](bytes: Array[Byte])
                                         (implicit consModule: ConsensusModule[TMOD],
                                          transModule: TMOD): Try[Block] = Try {

    val version = bytes.head

    var position = 1

    val timestamp = Longs.fromByteArray(bytes.slice(position, position + 8))
    position += 8

    val cBytesLength = Ints.fromByteArray(bytes.slice(position, position + 4))
    position += 4
    val cBytes = bytes.slice(position, position + cBytesLength)
    val consBlockField = consModule.builder.parseBytes(cBytes).get
    position += cBytesLength

    val tBytesLength = Ints.fromByteArray(bytes.slice(position, position + 4))
    position += 4
    val tBytes = bytes.slice(position, position + tBytesLength)
    val txBlockField = transModule.builder.parseBytes(tBytes).get
    position += tBytesLength

    new Block {

      override type TM = TMOD
      override type CM = ConsensusModule[TMOD]

      override val transactionDataField = txBlockField.asInstanceOf[BlockField[TransactionDataType]]

      override implicit val consensusModule = consModule
      override implicit val transactionModule = transModule

      override val versionField: ByteBlockField = ByteBlockField("version", version)

      override val consensusDataField = consBlockField.asInstanceOf[BlockField[ConsensusDataType]]

      override val timestampField: LongBlockField = LongBlockField("timestamp", timestamp)
    }
  }.recoverWith { case t: Throwable =>
    log.error("Error when parsing block", t)
    t.printStackTrace()
    Failure(t)
  }

  def build[TMo <: TransactionModule, CMo <: ConsensusModule[TMo]](version: Byte,
                                                                   timestamp: Long,
                                                                   consensusData: CMo#ConsensusBlockData,
                                                                   transactionData: TMo#TBD)
                                                                  (implicit consModule: CMo,
                                                                   transModule: TMo): Block = {
    new Block {

      override type TM = TMo
      override type CM = CMo

      override implicit val transactionModule: TM = transModule
      override implicit val consensusModule: CM = consModule

      override val versionField: ByteBlockField = ByteBlockField("version", version)

      override val transactionDataField = transactionModule.builder.formBlockData(transactionData.asInstanceOf[transactionModule.TBD])

      override val consensusDataField = consensusModule.builder.formBlockData(consensusData.asInstanceOf[consensusModule.ConsensusBlockData])
      override val timestampField: LongBlockField = LongBlockField("timestamp", timestamp)
    }
  }

  def genesis[TMOD <: TransactionModule](timestamp: Long = 0L)(implicit transModule: TMOD, consModule: ConsensusModule[TMOD]): Block = new Block {
    override type TM = TMOD
    override type CM = consModule.type

    override implicit val transactionModule: TM = transModule
    override implicit val consensusModule: CM = consModule

    override val versionField: ByteBlockField = ByteBlockField("version", 1)
    override val transactionDataField = transactionModule.builder.genesisData
    override val consensusDataField = consensusModule.builder.genesisData

    override val timestampField: LongBlockField = LongBlockField("timestamp", timestamp)
  }
}